package database

import (
	"context"
	"fmt"
	"github.com/go-logr/logr"
	goharborv1 "github.com/goharbor/harbor-cluster-operator/apis/goharbor.io/v1alpha1"
	"github.com/goharbor/harbor-cluster-operator/controllers/k8s"
	"github.com/goharbor/harbor-cluster-operator/lcm"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/tools/record"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

type PostgreSQLReconciler struct {
	HarborCluster *goharborv1.HarborCluster
	Ctx           context.Context
	Client        k8s.Client
	Recorder      record.EventRecorder
	Log           logr.Logger
	DClient       k8s.DClient
	Scheme        *runtime.Scheme
	ExpectCR      *unstructured.Unstructured
	ActualCR      *unstructured.Unstructured
	Labels        map[string]string
}

// Reconciler implements the reconcile logic of postgreSQL service
func (postgres *PostgreSQLReconciler) Reconcile() (*lcm.CRStatus, error) {

	postgres.Client.WithContext(postgres.Ctx)
	postgres.DClient.WithContext(postgres.Ctx)

	crdClient := postgres.DClient.WithResource(databaseFailoversGVR).WithNamespace(postgres.HarborCluster.Namespace)
	if postgres.HarborCluster.Spec.Database.Kind == goharborv1.InClusterComponent {

		name := fmt.Sprintf("%s-%s", postgres.HarborCluster.Namespace, postgres.HarborCluster.Name)
		actualCR, err := crdClient.Get(name, metav1.GetOptions{})
		if errors.IsNotFound(err) {
			return postgres.Provision()
		} else if err != nil {
			return databaseNotReadyStatus(GetDatabaseCrError, err.Error()), err
		}
		expectCR, err := postgres.generatePostgresCR()
		if err != nil {
			return databaseNotReadyStatus(GenerateDatabaseCrError, err.Error()), err
		}

		if err := controllerutil.SetControllerReference(postgres.HarborCluster, expectCR, postgres.Scheme); err != nil {
			return databaseNotReadyStatus(SetOwnerReferenceError, err.Error()), err
		}

		postgres.ActualCR = actualCR
		postgres.ExpectCR = expectCR

		crStatus, err := postgres.Update()
		if err != nil {
			return crStatus, err
		}
	}

	crStatus, err := postgres.Readiness()
	if err != nil {
		return databaseNotReadyStatus(CheckDatabaseHealthError, err.Error()), err
	}

	return crStatus, nil
}

func (postgres *PostgreSQLReconciler) Provision() (*lcm.CRStatus, error) {
	return postgres.Deploy()
}

func (postgres *PostgreSQLReconciler) Delete() (*lcm.CRStatus, error) {
	panic("implement me")
}

func (postgres *PostgreSQLReconciler) Scale() (*lcm.CRStatus, error) {
	panic("implement me")
}

func (postgres *PostgreSQLReconciler) ScaleUp(newReplicas uint64) (*lcm.CRStatus, error) {
	panic("implement me")
}

func (postgres *PostgreSQLReconciler) ScaleDown(newReplicas uint64) (*lcm.CRStatus, error) {
	panic("implement me")
}
